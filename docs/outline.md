# tensor-forge — Project Specification

A minimal compute graph runtime in Rust for executing tensor operations using a pluggable kernel registry and deterministic execution engine.

This project demonstrates the core architectural components of modern ML runtimes (XLA, PyTorch dispatcher, TensorFlow runtime) in a minimal, readable implementation suitable for systems programming and runtime infrastructure exploration.

---

# 1. Project Objectives

## Primary Goals

Implement a Rust library that provides:

- A dense tensor abstraction  
- A compute graph intermediate representation (IR)  
- A kernel abstraction layer  
- A kernel registry and dispatcher  
- A deterministic graph execution engine  
- Shape validation and runtime correctness guarantees  

The system must execute compute graphs such as:

Input → MatMul → Add → ReLU → Output

---

# 2. System Architecture Overview

tensor-forge consists of five primary subsystems:

- Tensor layer  
- Graph IR layer  
- Kernel abstraction layer  
- Kernel registry  
- Execution engine  

Execution flow:

`User constructs graph → graph validates → executor schedules → kernels execute → outputs produced`

---

# 3. Module Structure

(Tentative) Crate layout:

```
src/lib.rs  
src/tensor.rs  
src/graph.rs  
src/node.rs  
src/op.rs  
src/executor.rs  
src/kernel.rs  
src/registry.rs  
src/error.rs  

tests/tensor_tests.rs  
tests/kernel_tests.rs  
tests/graph_tests.rs  
tests/integration_tests.rs  
```

---

# 4. Tensor Layer Specification

File: `tensor.rs`

## Responsibilities

Represent dense multidimensional arrays stored in contiguous memory.

---

## Data Structure

Tensor fields:

`shape: Vec<usize>`  
`data: Vec<f64>`

Invariant:

`product(shape) == data.len()`

Layout:

Row-major contiguous

Example memory layout for shape `[2,3]`:

`[a00, a01, a02, a10, a11, a12]`

---

## Public API

Constructor functions:

`Tensor::from_vec(shape: impl Into<Vec<usize>>, data: Vec<f64>) -> Result<Tensor, Error>`

`Tensor::zeros(shape: impl Into<Vec<usize>>) -> Result<Tensor, Error>`

Inspection:

`Tensor::shape(&self) -> &[usize]`

`Tensor::numel(&self) -> usize`

`Tensor::data(&self) -> &[f64]`

`Tensor::data_mut(&mut self) -> &mut [f64]`

Validation:

Must return error if shape does not match data length.

---

# 5. Operator System Specification

File: `op.rs`

Defines supported operations.

Enums:

`pub enum OpKind { Input, MatMul, Add, ReLU }`

This enum represents graph-level operation identity.

---

# 6. Graph IR Specification

Files:

`graph.rs`  
`node.rs`

---

## Node

Represents one operation instance in graph.

Fields:

```
pub struct Node { 
    pub id: NodeId, 
    pub op: OpKind, 
    pub inputs: Vec<NodeId>, 
    pub shape: Vec<usize> 
}
```

- `node.shape` has two interpretations:
    - If `op == OpKind::Input`: `shape` is the shape of the input tensor.
    - Else: `shape` is the shape of the output tensor produced by this node.

NodeId type:

```
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NodeId(pub usize);
```

`Node` and `NodeId` structs are generated by interacting with the `Graph` API and 
should not be instantiated or modified directly. Their fields are public, however, 
and may be read freely.

---

## Graph

Fields:

```
pub struct Graph { 
    nodes: HashMap<NodeId, Node>,
    inputs: Vec<NodeId>, 
    outputs: Vec<NodeId> }
```

`nodes` stores graph nodes indexed by `NodeId` for O(1) lookup.

Execution order is determined via deterministic topological sorting of the graph.

Graph is append-only: nodes may be added but never removed or mutated in a way that invalidates dependency relationships.

This guarantees:

- All node dependencies execute before the node itself
- Execution order is deterministic across runs
- Execution order does not depend on HashMap iteration order

---

## Public API

`Graph::new() -> Graph`

`Graph::input_node(shape: Vec<usize>) -> NodeId`

`Graph::matmul(lhs: NodeId, rhs: NodeId) -> Result<NodeId, Error>`

`Graph::add(lhs: NodeId, rhs: NodeId) -> Result<NodeId, Error>`

`Graph::relu(input: NodeId) -> Result<NodeId, Error>`

`Graph::set_output_node(node: NodeId) -> Result<(), GraphError>`

`Graph::node(id: NodeId) -> Result<&Node, GraphError>`

`Graph::num_nodes() -> usize`

`Graph::inputs(&self) -> &[NodeId]`

`Graph::outputs(&self) -> &[NodeId]`

`Graph::topo_sort(&self) -> Result<Vec<NodeId>, GraphError>`

Nodes are created internally by `Graph::{input, matmul, add, relu}` and appended to `Graph.nodes`. Users never construct Node directly -- they only receive NodeId handles.

> NodeId is only valid for the Graph instance that created it.
> 
> Using a NodeId from a different graph is a runtime error and will return GraphError::InvalidNodeId.

---

## Execution Ordering

Graph execution order is computed using deterministic topological sorting.

Topological sorting ensures:

- All node dependencies execute before dependent nodes
- Execution order is valid for arbitrary DAG structures
- Execution order is deterministic across runs

Determinism is achieved by breaking ties using ascending NodeId order.

This guarantees reproducible execution regardless of HashMap internal ordering.

---

## Shape Validation Rules

MatMul rule:

`[A, B] × [B, C] → [A, C]`

Addition rule:

`Shapes must match exactly`

ReLU rule:

`Output shape = input shape`

Graph construction must fail immediately if shapes invalid.

---

# 7. Kernel Abstraction Specification

File: `kernel.rs`

Defines runtime-executable compute kernels.

Traits:

`pub trait Kernel { fn compute(&self, inputs: &[&Tensor], output: &mut Tensor) -> Result<(), Error>; }`

---

## Kernel Implementations

- MatMulKernel

- AddKernel

- ReluKernel

---

# 8. Kernel Registry Specification

File: `registry.rs`

Responsible for mapping OpKind → Kernel.

Data structure:

`pub struct KernelRegistry { kernels: HashMap<OpKind, Box<dyn Kernel>> }`

---

## API

`KernelRegistry::new() -> KernelRegistry`

`KernelRegistry::register(op: OpKind, kernel: Box<dyn Kernel>) -> Option<Box<dyn Kernel>>`

`KernelRegistry::get(op: OpKind) -> Option<&dyn Kernel>`

> `KernelRegistry::register` swaps and returns an old mapping if it exists. 

---

## Default Registry

Must register:

- MatMulKernel  
- AddKernel  
- ReluKernel  

`KernelRegistry::default()`

---

# 9. Execution Engine Specification

File: `executor.rs`

Responsible for executing graphs.

Executor fields:

`pub struct Executor { registry: KernelRegistry }`

---

## Execution Algorithm

Input:

- Graph  
- Input tensors  

Steps:

1. Allocate tensor storage for every node  
2. Assign input tensors  
3. Execute nodes in graph order  
4. For each node:  

   - Fetch kernel  
   - Fetch input tensors  
   - Allocate output tensor  
   - Call kernel.compute  

5. Return outputs  

Execution order:

Nodes execute in deterministic topological order.

This ensures correct dependency resolution and reproducible execution.

---

## API

`Executor::new(registry: KernelRegistry) -> Executor`

`Executor::execute(&self, graph: &Graph, inputs: &[Tensor]) -> Result<Vec<Tensor>, Error>`

Input tensors are provided in the same order as `Graph::input()` calls (i.e., the order of `graph.inputs`). Mismatched count is `InvalidInput`.

---

# 10. Error Handling Specification

File: `error.rs`

Define:

`pub enum Error { ShapeMismatch, InvalidInput, KernelNotFound, ExecutionError, GraphError }`

Must implement:

- Debug  
- Display  
- std::error::Error  

---

# 11. Testing

---

## Tensor Tests

File: `tests/tensor_tests.rs`

Tests:

- [X] tensor_creation_valid  
- [X] tensor_creation_invalid_shape  
- [X] tensor_zeros_correct_size  
- [X] tensor_mutability_test  

---

## Graph Tests

File: `tests/graph_tests.rs`

Tests:

- [X] graph_creation_valid
- [X] graph_node_creation
- [X] graph_missing_input_nodes
- [X] graph_relu
- [X] graph_add_matrices
- [X] graph_add_matmul_node
- [X] graph_matmul_invalid_dimensions
- [X] graph_chained_matmul
- [X] graph_chain_full_implementation

---

## Topological Sort Tests

File: `tests/topo_sort_tests.rs`

Tests:
- [X] test topo_sort_is_deterministic_for_independent_nodes
- [X] test topo_sort_diamond_orders_all_dependencies_first
- [X] test topo_sort_linear_orders_dependencies_first
- [X] test topo_sort_is_deterministic_for_multiple_ready_ops

---

## Kernel Tests

File: `tests/kernel_tests.rs`

Tests:

- [X] add_kernel_basic
- [X] add_kernel_complex
- [X] add_kernel_input_shape_mismatch
- [X] add_kernel_invalid_arity_one_input
- [X] add_kernel_infinity_and_nan_semantics
- [X] add_kernel_invalid_arity_zero_inputs
- [X] add_kernel_invalid_arity_three_inputs
- [X] add_kernel_output_shape_mismatch
- [X] add_kernel_overflow_f64_to_infinity
- [X] add_kernel_signed_zero_behavior
- [X] kernel_integration_matmul_add_relu_pipeline
- [X] kernel_integration_relu_matmul_add_graph
- [X] matmul_kernel_chain
- [X] matmul_kernel_identity_right
- [X] matmul_kernel_invalid_arity
- [X] matmul_kernel_basic_rectangular
- [X] matmul_kernel_output_shape_mismatch
- [X] matmul_kernel_zeros
- [X] matmul_kernel_shape_mismatch
- [X] relu_kernel_all_negative
- [X] relu_kernel_all_positive
- [X] relu_kernel_basic
- [X] relu_kernel_infinity_handling
- [X] relu_kernel_invalid_arity_two_inputs
- [X] relu_kernel_invalid_arity_zero_inputs
- [X] relu_kernel_invalid_output_shape
- [X] relu_kernel_nan_propagation
- [X] relu_kernel_preserves_shape

---

## Kernel Registry Tests

File: `tests/kernel_registry_tests.rs`

Tests:

- [X] registry_can_register_multiple_ops
- [X] registry_default_has_expected_kernels
- [X] registry_dispatch_matmul_add_relu_works
- [X] registry_overwrite_returns_old
- [X] registry_get_missing_returns_none
- [X] registry_register_then_get_returns_kernel

---
## Executor Tests

File: `tests/integration_tests.rs`

Tests:

- [ ] simple relu execution test  
- [ ] add graph execution test  
- [ ] matmul graph execution test  
- [ ] multi-op graph test:
- [ ] matmul → add → relu
- [ ] Verify final output values.

---

# 12. crates.io Readiness Requirements

Before publishing, verify:

`cargo test`

`cargo fmt`

`cargo clippy`

`cargo doc --no-deps`

Additional requirements:

- [ ] Github Actions and README.md buttons that verify the above requirements

- [ ] Code builds with `#![deny(clippy::all)]` and `#![deny(missing_docs)]`

All must succeed with no warnings.

---

# 13. Implementation Plan

---

# Phase 1 — Tensor and Graph IR

[COMPLETE] Goal: Complete tensor layer and graph structure

Checklist:

- [X] Create crate  

- [X] Implement Tensor struct  

- [X] Write Tensor tests  

- [X] Implement Tensor constructors  

- [X] Implement Tensor validation  

- [X] Write Tensor documentation  

- [X] Implement Node struct  

- [X] Implement Graph struct  

- [X] Write Graph tests  

- [X] Implement Graph input nodes  

- [X] Implement Graph shape validation  

- [X] Implement matmul/add/relu graph ops  

Completion criteria:

✅ Graph builds successfully and tests pass.

---

# Phase 2 — Kernel System and Registry

Goal: Functional compute layer

Checklist:

- [X] Implement Kernel trait  

- [X] Write Kernel tests  

- [X] Implement MatMulKernel  

- [X] Implement AddKernel  

- [X] Implement ReluKernel  

- [X] Write KernelRegistry tests

- [X] Implement KernelRegistry  

Completion criteria:

✅ kernels produce correct outputs and tests pass.

---

# Phase 3 — Executor and Integration

Goal: Full runtime execution

Checklist:

- [ ] Implement graph topological sort  

- [ ] Implement Executor  

- [ ] Implement graph execution loop  

- [ ] Implement tensor storage allocation  

- [ ] Implement kernel dispatch  

- [ ] Implement output handling  

- [ ] Write integration tests  

- [ ] Finalize README  

- [ ] Final polish  

Completion criteria:

End-to-end graph execution works correctly.

---

# Final Deliverable Definition

Project is complete when:

- [ ] All tests pass  

- [ ] Code compiles cleanly  

- [ ] Well-documented README exists  

- [ ] Code refactored and cleanly structured

- [ ] 90-95% Functional, Line, Region, and Branch Coverage metrics

- [ ] Rustdocs are up-to-date

- [ ] Project published to crates.io  

---
